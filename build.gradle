plugins {
    id 'application'
    id 'jacoco'
    id 'checkstyle'
    id 'com.github.spotbugs' version '6.0.7'
}

// Version checking example using Gradle's version comparison
def minimumGradleVersion = "8.0"
def currentGradleVersion = gradle.gradleVersion

// Simple version comparison without importing VersionNumber
if (currentGradleVersion.split('\\.')[0].toInteger() < minimumGradleVersion.split('\\.')[0].toInteger()) {
    throw new GradleException("This project requires Gradle ${minimumGradleVersion} or higher. Current version: ${currentGradleVersion}")
}

println "âœ“ Gradle version check passed: ${currentGradleVersion}"

compileJava {
    options.encoding = 'UTF-8'
}

compileTestJava {
    options.encoding = 'UTF-8'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17) // ë¹Œë“œ JDK ê³ ì •
    }
}

repositories {
    mavenCentral()
}

application {
    // ë©”ì¸ í´ë˜ìŠ¤ FQCN
    mainClass = 'tetris.Tetris'
}

dependencies {
    
    implementation "javazoom:jlayer:1.0.1"
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.2'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    
    // í…ŒìŠ¤íŠ¸ ë¦¬í¬íŒ…ì„ ìœ„í•œ ì˜ì¡´ì„±
    testImplementation 'org.junit.jupiter:junit-jupiter-engine:5.10.2'
    testImplementation 'org.junit.jupiter:junit-jupiter-params:5.10.2'
}

test {
    useJUnitPlatform()
    
    // í…ŒìŠ¤íŠ¸ ë³‘ë ¬ ì‹¤í–‰ ë¹„í™œì„±í™” - ë¬´í•œ ë£¨í”„ ë°©ì§€ë¥¼ ìœ„í•´ ìˆœì°¨ ì‹¤í–‰
    maxParallelForks = 1
    forkEvery = 1
    
    // GUI í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ í—¤ë“œë¦¬ìŠ¤ ëª¨ë“œ ë¹„í™œì„±í™”
    // systemProperty 'java.awt.headless', 'true'  // ì£¼ì„ ì²˜ë¦¬
    systemProperty 'junit.jupiter.execution.parallel.enabled', 'false'
    
    // ê° í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ë³„ íƒ€ì„ì•„ì›ƒ ê°•í™”
    systemProperty 'junit.jupiter.execution.timeout.default', '30s'
    systemProperty 'junit.jupiter.execution.timeout.testable.method.default', '30s'
    
    // í…ŒìŠ¤íŠ¸ ë¦¬í¬íŠ¸ ìƒì„± ì„¤ì •
    reports {
        junitXml.required = true
        html.required = true
    }
    
    // í…ŒìŠ¤íŠ¸ ê²°ê³¼ë¥¼ XML í˜•íƒœë¡œ ì¶œë ¥ (GitHub Actions í˜¸í™˜)
    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat "full"
        showStandardStreams = true  // System.out.println ì¶œë ¥ í™œì„±í™”
        
        // í…ŒìŠ¤íŠ¸ ì™„ë£Œ í›„ ìš”ì•½ ì •ë³´ ì¶œë ¥
        afterSuite { desc, result ->
            if (!desc.parent) { // ë£¨íŠ¸ í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸ì¸ ê²½ìš°
                println ""
                println "=" * 50
                println "ğŸ§ª JUnit í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ê²°ê³¼"
                println "=" * 50
                println "ì´ í…ŒìŠ¤íŠ¸: ${result.testCount}"
                println "ì„±ê³µ: ${result.successfulTestCount}"
                println "ì‹¤íŒ¨: ${result.failedTestCount}"
                println "ê±´ë„ˆëœ€: ${result.skippedTestCount}"
                println "ì‹¤í–‰ ì‹œê°„: ${result.endTime - result.startTime}ms"
                
                if (result.failedTestCount > 0) {
                    println "âŒ ì¼ë¶€ í…ŒìŠ¤íŠ¸ê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
                } else {
                    println "âœ… ëª¨ë“  í…ŒìŠ¤íŠ¸ê°€ ì„±ê³µí–ˆìŠµë‹ˆë‹¤!"
                }
                println "=" * 50
                println ""
            }
        }
    }
    
    // í…ŒìŠ¤íŠ¸ íƒ€ì„ì•„ì›ƒ ì„¤ì • - ê°•í™”
    timeout = Duration.ofMinutes(3)  // ì „ì²´ í…ŒìŠ¤íŠ¸ íƒ€ì„ì•„ì›ƒì„ 3ë¶„ìœ¼ë¡œ ë‹¨ì¶•
    
    // JVM ì˜µì…˜ ì¶”ê°€ - ë¬´í•œ ë£¨í”„ ë°©ì§€ ê°•í™”
    jvmArgs '-XX:+UseG1GC', '-Xmx512m', '-XX:+HeapDumpOnOutOfMemoryError',
            '-XX:+ExitOnOutOfMemoryError', '-XX:MaxDirectMemorySize=128m'
    
    // ê°œë³„ í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ë³„ ê°•ì œ ì¢…ë£Œ íƒ€ì„ì•„ì›ƒ
    systemProperty 'junit.jupiter.execution.timeout.mode', 'enabled'
    
    // í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨ ì‹œì—ë„ ê³„ì† ì§„í–‰ (ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ ìƒì„±ì„ ìœ„í•´)
    ignoreFailures = true
    
    // ë¬¸ì œìˆëŠ” í…ŒìŠ¤íŠ¸ ì œì™¸ (í•„ìš”ì‹œ)
    exclude '**/*LongRunning*'
}

// í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ì„¤ì •
jacoco {
    toolVersion = "0.8.8"
}

jacocoTestReport {
    dependsOn test
    
    reports {
        xml.required = true
        html.required = true
        csv.required = true  // CSV ë¦¬í¬íŠ¸ë„ í™œì„±í™”í•˜ì—¬ ì½˜ì†” ì¶œë ¥ìš©ìœ¼ë¡œ ì‚¬ìš©
    }
    
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: [
                // ë©”ì¸ í´ë˜ìŠ¤ë‚˜ UI í´ë˜ìŠ¤ ì œì™¸ (ì„ íƒì‚¬í•­)
                '**/Tetris.class',
                '**/Main.class'
            ])
        }))
    }
    
    // ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ ìƒì„± í›„ ì½˜ì†”ì— ìš”ì•½ ì •ë³´ ì¶œë ¥
    doLast {
        def csvFile = reports.csv.outputLocation.asFile.get()
        if (csvFile.exists()) {
            def coverageData = parseCoverageData(csvFile)
            printCoverageSummary(coverageData)
        }
        
        println ""
        println "ğŸ“Š í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤:"
        println "   HTML: ${reports.html.outputLocation.asFile.get().toURI()}"
        println "   XML:  ${reports.xml.outputLocation.asFile.get()}"
        println ""
    }
}

// í…ŒìŠ¤íŠ¸ ì‹¤í–‰ í›„ ìë™ìœ¼ë¡œ ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ ìƒì„±
test.finalizedBy jacocoTestReport

// ì»¤ë²„ë¦¬ì§€ ë°ì´í„° íŒŒì‹± í•¨ìˆ˜
def parseCoverageData(csvFile) {
    def lines = csvFile.readLines()
    if (lines.size() < 2) return null
    
    def totalInstructions = 0
    def coveredInstructions = 0
    def totalBranches = 0
    def coveredBranches = 0
    def totalLines = 0
    def coveredLines = 0
    
    // CSV í—¤ë”ë¥¼ ê±´ë„ˆë›°ê³  ë°ì´í„° í–‰ë“¤ì„ ì²˜ë¦¬
    lines[1..-1].each { line ->
        def parts = line.split(',')
        if (parts.size() >= 12) {
            totalInstructions += parts[3] as Integer
            coveredInstructions += parts[4] as Integer
            totalBranches += parts[5] as Integer
            coveredBranches += parts[6] as Integer
            totalLines += parts[7] as Integer
            coveredLines += parts[8] as Integer
        }
    }
    
    return [
        instructions: [total: totalInstructions, covered: coveredInstructions],
        branches: [total: totalBranches, covered: coveredBranches],
        lines: [total: totalLines, covered: coveredLines]
    ]
}

// ì»¤ë²„ë¦¬ì§€ ìš”ì•½ ì •ë³´ ì¶œë ¥ í•¨ìˆ˜
def printCoverageSummary(coverageData) {
    if (!coverageData) {
        println "âš ï¸ ì»¤ë²„ë¦¬ì§€ ë°ì´í„°ë¥¼ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
        return
    }
    
    def instructionCoverage = coverageData.instructions.total > 0 ? 
        (coverageData.instructions.covered / coverageData.instructions.total * 100) : 0
    def branchCoverage = coverageData.branches.total > 0 ? 
        (coverageData.branches.covered / coverageData.branches.total * 100) : 0
    def lineCoverage = coverageData.lines.total > 0 ? 
        (coverageData.lines.covered / coverageData.lines.total * 100) : 0
    
    println ""
    println "=" * 60
    println "ğŸ“Š JUnit í…ŒìŠ¤íŠ¸ ì½”ë“œ ì»¤ë²„ë¦¬ì§€ ê²°ê³¼"
    println "=" * 60
    printf "ğŸ“‹ ë¼ì¸ ì»¤ë²„ë¦¬ì§€:        %d/%d (%.1f%%)\n", 
        coverageData.lines.covered, coverageData.lines.total, lineCoverage
    printf "ğŸ¯ ëª…ë ¹ì–´ ì»¤ë²„ë¦¬ì§€:      %d/%d (%.1f%%)\n", 
        coverageData.instructions.covered, coverageData.instructions.total, instructionCoverage
    printf "ğŸ”€ ë¶„ê¸° ì»¤ë²„ë¦¬ì§€:        %d/%d (%.1f%%)\n", 
        coverageData.branches.covered, coverageData.branches.total, branchCoverage
    println "=" * 60
    
    // ì»¤ë²„ë¦¬ì§€ í’ˆì§ˆ í‰ê°€
    def overallCoverage = lineCoverage
    if (overallCoverage >= 80) {
        println "âœ… ìš°ìˆ˜í•œ ì½”ë“œ ì»¤ë²„ë¦¬ì§€ì…ë‹ˆë‹¤! (80% ì´ìƒ)"
    } else if (overallCoverage >= 60) {
        println "âš ï¸ ì–‘í˜¸í•œ ì½”ë“œ ì»¤ë²„ë¦¬ì§€ì…ë‹ˆë‹¤. (60-80%)"
    } else if (overallCoverage >= 40) {
        println "ğŸ”¶ ê°œì„ ì´ í•„ìš”í•œ ì½”ë“œ ì»¤ë²„ë¦¬ì§€ì…ë‹ˆë‹¤. (40-60%)"
    } else {
        println "ğŸ”´ ì½”ë“œ ì»¤ë²„ë¦¬ì§€ê°€ ë‚®ìŠµë‹ˆë‹¤. ì¶”ê°€ í…ŒìŠ¤íŠ¸ê°€ í•„ìš”í•©ë‹ˆë‹¤. (40% ë¯¸ë§Œ)"
    }
    println ""
}

// JAR íŒŒì¼ ìƒì„± ì„¤ì •
jar {
    manifest {
        attributes 'Main-Class': 'tetris.Tetris'
    }
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}


// ===== exe ë¹Œë“œ ê´€ë ¨ =====

// --- dist ì •ë¦¬: Delete íƒ€ì…ìœ¼ë¡œ ê¹”ë”í•˜ê²Œ ---
tasks.register('cleanDist', Delete) {
    delete layout.projectDirectory.dir('dist')
}

// --- jpackage : app-image ---
tasks.register('jpackageExe', Exec) {
    dependsOn 'cleanDist', 'jar'
    group = 'distribution'
    description = 'Creates a native application image with icon'

    def jp = "${System.getProperty('java.home')}/bin/jpackage.exe"
    
    // ì•„ì´ì½˜ íŒŒì¼ í™•ì¸
    def iconFile = file("D:/SE/SE_Tetris_Team1/src/main/resources/Tetris.ico")
    def commandArgs = [
        '--input', 'build/libs',
        '--main-jar', jar.archiveFileName.get(),
        '--main-class', 'tetris.Tetris',
        '--name', 'Tetris Game',
        '--type', 'app-image',
        '--dest', 'dist',
        '--vendor', 'SE_Tetris_Team1',
        '--description', 'Tetris Game with Items and Difficulty Modes',
        '--app-version', '1.0.0'
    ]
    
    // ì•„ì´ì½˜ íŒŒì¼ì´ ì¡´ì¬í•˜ë©´ ì¶”ê°€
    if (iconFile.exists()) {
        commandArgs.add('--icon')
        commandArgs.add(iconFile.absolutePath)
        println "Using icon file: ${iconFile.absolutePath}"
    } else {
        println "Warning: icon.ico not found. Building without icon."
    }
    
    commandLine([jp] + commandArgs)
}

// Checkstyle ì„¤ì • (ë¹„í™œì„±í™”)
checkstyle {
    toolVersion = '8.45.1'
    configFile = file("${rootDir}/config/checkstyle/checkstyle.xml")
    ignoreFailures = true
}

// Checkstyle ì‘ì—…ì„ ê±´ë„ˆë›°ë„ë¡ ì„¤ì •
tasks.withType(Checkstyle) {
    enabled = false
}

// SpotBugs ì„¤ì •
spotbugs {
    ignoreFailures = true  // ë¹Œë“œ ì‹¤íŒ¨ë¥¼ ë°©ì§€í•˜ê³  ê²½ê³ ë¡œë§Œ ì²˜ë¦¬
    reportLevel = 'medium'
    effort = 'default'
}

spotbugsMain {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/main/spotbugs.html")
        }
    }
}

spotbugsTest {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/test/spotbugs.html")
        }
    }
}

// ===== ì»¤ë²„ë¦¬ì§€ ê´€ë ¨ í¸ì˜ íƒœìŠ¤í¬ë“¤ =====

// í…ŒìŠ¤íŠ¸ + ì»¤ë²„ë¦¬ì§€ í•œ ë²ˆì— ì‹¤í–‰
tasks.register('testWithCoverage') {
    group = 'verification'
    description = 'JUnit í…ŒìŠ¤íŠ¸ ì‹¤í–‰ í›„ ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ ìƒì„± ë° ì½˜ì†” ì¶œë ¥'
    dependsOn test, jacocoTestReport
}

// ì»¤ë²„ë¦¬ì§€ë§Œ ë‹¤ì‹œ ìƒì„± (í…ŒìŠ¤íŠ¸ëŠ” ì‹¤í–‰í•˜ì§€ ì•ŠìŒ)
tasks.register('coverageReport') {
    group = 'reporting'
    description = 'ê¸°ì¡´ í…ŒìŠ¤íŠ¸ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ë§Œ ë‹¤ì‹œ ìƒì„±'
    dependsOn jacocoTestReport
}

// ì»¤ë²„ë¦¬ì§€ ê²€ì¦ íƒœìŠ¤í¬ (ìµœì†Œ ì»¤ë²„ë¦¬ì§€ ê¸°ì¤€ ì„¤ì •)
jacocoTestCoverageVerification {
    dependsOn jacocoTestReport
    
    violationRules {
        rule {
            limit {
                minimum = 0.60  // ìµœì†Œ 60% ë¼ì¸ ì»¤ë²„ë¦¬ì§€ ìš”êµ¬
            }
        }
        
        rule {
            enabled = true
            element = 'CLASS'
            excludes = ['**.*Test*', '**.*Main*', '**.*Tetris*']
            
            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 0.6  // ê°œë³„ í´ë˜ìŠ¤ëŠ” ìµœì†Œ 60% ì»¤ë²„ë¦¬ì§€
            }
        }
    }
}
